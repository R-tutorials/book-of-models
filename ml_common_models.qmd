
# Common Models



Let's get one thing straight from the outset: **any model may be used in machine learning**, from a standard linear model to a deep neural network. The focus in ML is on performance, not on inference.  This means that the modeler is often less concerned with the interpretation of the model, but rather with the ability of the model to predict well on new data. In this chapter, we will explore some of the more common machine learning models and techniques. 


```{r}
#| include: False
#| label: setup-ml-models
source("load_packages.R")
source("setup.R")

library(tidyverse)
library(glue)
reticulate::use_condaenv("book-of-models")
```

## Key Ideas

The take home messages from this section include the following:

- Any model can be used with machine learning
- A good and simple baseline is essential for interpreting your performance results
- One only needs a small set of tools (models) to go very far with machine learning

### Why this matters

Having good choices in your data science toolbox means you don't have to waste time with nuance and can get down to what matters- performance! Furthermore, using these common tools means you'll know you're in good company, and that you'll be able to find many resources to help you along the way. Additionally, you'll be able to focus on the data and the problem at hand, rather than the model, which in the end, is just a tool to help you understand the data. If you can get a good understanding of the data with a simple model, then that may be all you need for your situation. If you decide you need a more complex modeling approach, then using these models will still give you a good understanding of what you should expect in terms of performance.


## Data setup

```{r}
#| eval: true
#| echo: false
#| label: load-spam-data
library(tidyverse)
# df_adult = read_csv("data/adult.csv") # almost all cat vars
# df_spam  # too few vars
# df_heart = read_csv("data/heart_failure.csv") 



# df_heart_labeled = df_heart %>%
#   mutate(
#     anaemia = ifelse(anaemia == 1, "yes", "no"),
#     diabetes = ifelse(diabetes == 1, "yes", "no"),
#     high_blood_pressure = ifelse(high_blood_pressure == 1, "yes", "no"),
#     male = ifelse(male == 1, "yes", "no"),
#     smoking = ifelse(smoking == 1, "yes", "no"),
#     death = ifelse(death == 1, "yes", "no")
#   )

# write_csv(df_heart_labeled, "data/heart_failure_labeled.csv")


# df_income = read_csv("data/census_income.csv", na = c("", "NA", '?'))
df_heart = read_csv("data/heart_disease_processed.csv")
df_heart_num = read_csv("data/heart_disease_processed_numeric.csv")
```


```{python}
#| eval: false
#| echo: false
#| label: uci heart
from ucimlrepo import fetch_ucirepo
import pandas as pd

# fetch dataset
heart_disease = fetch_ucirepo(id=45)

# data (as pandas dataframes)
X = heart_disease.data.features
y = heart_disease.data.targets

# metadata
# print(heart_disease.metadata)

# variable information
# print(heart_disease.variables)

df_heart = (
    X.assign(
        cp=pd.Categorical(X.cp).rename_categories(
            ['typical', 'atypical', 'non-anginal', 'asymptomatic']
        ),
        fbs=pd.Categorical(X.fbs).rename_categories(['<= 120 mg/dl', '> 120 mg/dl']),
        restecg=pd.Categorical(X.restecg).rename_categories(
            ['normal', 'ST-T wave abnormality', 'left ventricular hypertrophy']
        ),
        exang=pd.Categorical(X.exang).rename_categories(['no', 'yes']),
        slope=pd.Categorical(X.slope).rename_categories(
            ['upsloping', 'flat', 'downsloping']
        ),
        # ca = pd.Categorical(X.ca, categories = ['0', '1', '2', '3']),
        thal=pd.Categorical(X.thal).rename_categories(
            ['normal', 'fixed defect', 'reversible defect']
        ),
        heart_disease=pd.Categorical(y.num > 0).rename_categories(['no', 'yes']),
    ).rename(
        columns={
            'sex': 'male',
            'cp': 'chest_pain_type',
            'trestbps': 'resting_bp',
            'chol': 'cholesterol',
            'fbs': 'fasting_blood_sugar',
            'restecg': 'resting_ecg',
            'thalach': 'max_heart_rate',
            'exang': 'exercise_induced_angina',
            'oldpeak': 'st_depression',
            'ca': 'num_major_vessels',
            'thal': 'thalassemia',
        }
    )
)

df_heart.to_csv('data/heart_disease_processed.csv', index=False)
```

```{python}
#| echo: false
#| eval: false
#| label: uci numeric py

df_heart = pd.read_csv('data/heart_disease_processed.csv')

from sklearn.preprocessing import StandardScaler

cats = pd.get_dummies(
    df_heart[['chest_pain_type', 'resting_ecg', 'slope', 'thalassemia']]
).astype(int)

binaries = (
    pd.get_dummies(
        df_heart[['fasting_blood_sugar', 'exercise_induced_angina', 'heart_disease']],
        drop_first=True,
    )
    .astype(int)
    .rename(columns={'heart_disease_yes': 'heart_disease'})
)

ss = StandardScaler()

x = df_heart.drop(
    columns=[
        'chest_pain_type',
        'resting_ecg',
        'slope',
        'thalassemia',
        'fasting_blood_sugar',
        'exercise_induced_angina',
        'heart_disease',
    ]
)


pd.concat([x, cats, binaries], axis=1).to_csv(
    'data/heart_disease_processed_numeric.csv', index=False
)
x[x.columns] = ss.fit_transform(x)

pd.concat([x, cats, binaries], axis=1).to_csv(
    'data/heart_disease_processed_numeric_sc.csv', index=False
)
```

FIXME: add appendix link for dataset!

For our examples, we'll switch things up and use the heart disease dataset. This is a binary classification problem, where we want to predict whether a patient has heart disease, given information such as age, sex, resting heart rate etc. For more details see the appendix. We have done some initial data processing so that you can dive right in. There are two forms of the data, one which is purely numeric, where the binary category features are changed to dummies, and one with labels for those features. The purely numeric version will save any additional data processing for some model/package implementations.  In this data, roughly `r scales::percent(mean(df_heart$heart_disease == 'yes'))` suffered a death, so that is an initial baseline if we're interested in accuracy. 


:::{.panel-tabset}

##### Python


```{python}
#| label: setup-data-py

import pandas as pd
import numpy as np

df_heart = pd.read_csv('data/heart_disease_processed.csv')
df_heart_num = pd.read_csv('data/heart_disease_processed_numeric_sc.csv')

# convert appropriate features to categorical
for col in df_heart.select_dtypes(include='object').columns:
    df_heart[col] = df_heart[col].astype('category')

X = df_heart_num.drop(columns=['heart_disease']).to_numpy()
y = df_heart_num['heart_disease'].to_numpy()

# for LogisticRegression, which can't automatically handle missing data
y_complete = df_heart_num.dropna()['heart_disease'].to_numpy().astype(int)
X_complete = df_heart_num.dropna().drop(columns='heart_disease').to_numpy()
```


##### R

```{r}
#| label: setup-data-r

library(tidyverse)

df_heart = read_csv("data/heart_disease_processed.csv")#|> mutate(across(where(is.character), as.factor))
df_heart_num = read_csv("data/heart_disease_processed_numeric_sc.csv")

# as a data.frame for mlr3
X_num_df = df_heart_num %>%
    as_tibble() |> 
    mutate(heart_disease = factor(heart_disease)) |> 
    janitor::clean_names() # remove some symbols
```

:::


## Do Better than the Baseline

The baseline model should serve as a way to gauge how much better your model performs over one that is simpler and more interpretable, or one that is sufficiently complex to capture something about the data you are exploring, but not as complex as the models you're primarily interested in. Take a classification model for example. We could compare it to a logistic regression, which is as simple as it gets, but is often too simple to be adequately performant for many situations. 


### Why do we do this?

You can actually find articles in which deep learning models do not even beat a logistic regression on some datasets, but the fact of which did not stop the authors writing several pages hyping the more complex technique. Probably the most important reason to have a baseline is so that you can avoid wasting time and resources implementing more complex tools. It is probably rare, but sometimes relationships for the chosen features and target are mostly or nearly linear and have little interaction, and no amount of fancy modeling will make it come about. Furthermore, if our baseline is a complex linear model that actually incorporates nonlinear relationships and interactions (e.g. a GAMM), you'll often find that the more complex models don't significantly improve on the baseline by much, if at all. In addition, in time series settings, a moving average or last target value can often be a very good predictor. So in general, you may find that the initial baseline model is good enough for the time being, and you can then move on to other problems to solve, like acquiring data that is functionally predictive. This is especially true if you are working in a business setting where you have limited time and resources.  

A final note. In many (most?) settings, it often isn't enough to merely beat the baseline model. You should look to do statistically better. For example, if your complex model accuracy is 75% and your baseline is 73%, that's great, but you should check to see if that difference is statistically significant[^ifonlystatdiff], because those metrics are *estimates*, and they have uncertainty, which means you can get a range for them as well as test whether they are different from one another. If the difference is not notable, then you should probably stick with the baseline model or try something else, because the next time you run the model, the baseline may actually perform better, or at least you can't be sure that it won't.

That said, in some situations *any* performance increase is worth it, and even if we can't be certain a result is statistically better, any sign of improvement is worth pursuing. For example, if you are trying to predict the next word in a sentence, and your baseline is 10% accurate, and your complex model is 11% accurate, that's a 10% increase in accuracy, which may be a big deal for user experience. You should still work to show that this is a consistent increase and not a fluke.

[^ifonlystatdiff]: There would be far less hype and wasted time if those in ML and DL research simply did this rather than just reporting the chosen metric of their model 'winning' against other models. It's not that hard to do, yet most do not provide any ranged estimate for their metric, let alone test statistical difference from other models. You don't even have to bootstrap the metric estimates for binary classification! It'd also be nice if they used a more meaningful baseline than logistic regression, but that's a different story.


## Penalized Approaches

TODO: ADD LINK TO ESTIMATION CHAPTER

We show explictly how to estimate models like lasso and ridge regression in the estimation chapter. Those work well as a baseline and so should be in your ML toolbox. Remember also that they can be applied to any linear model setting, where your objective is MSE, log likelihood of a count or binary target, or what have you. It's good to keep them in mind.

### Elastic Net

Another common approach is **elastic net**, which is a combination of lasso and ridge.  We will not show how to estimate elastic net here, but all you have to know is that it has two penalties, the same ones for lasso and one for ridge, along with the standard objective for a numeric or categorical target. The relative size of the two penalties is controlled by a mixing parameter, and the optimal value of that parameter is determined by cross-validation.  So for example, you might end up with a 75% lasso penalty and 25% ridge penalty.  

Let's apply this to the heart disease data. We'll used the 'processed version' which has dummy codes and has dropped the few observations with missing values. We are only doing simple cross-validation here, but you are more than welcome to tune both the penalty paramter and the mixing ratio.

:::{.panel-tabset}

##### Python



```{python}
#| label: elasticnet-py
#| eval: false
from sklearn.linear_model import LogisticRegression, LogisticRegressionCV
from sklearn.model_selection import cross_validate, KFold, cross_val_score
from sklearn.metrics import accuracy_score


model_elastic = LogisticRegression(
    penalty='elasticnet',
    solver='saga',
    l1_ratio=0.5,
    random_state=42,
    max_iter=10000,
    verbose=False,
)

# model_elastic.fit(X_complete, y_complete)

 # use cross-validation to estimate performance
cv_elastic = cross_validate(
    model_elastic,
    X_complete,
    y_complete,
    cv=5,
    scoring='accuracy',
)
```

```{python}
#| label: elasticnet-py-save-results
#| echo: false
#| eval: false

pd.DataFrame(cv_elastic).to_csv('ml/data/elasticnet-py-results.csv', index=False)
```


```{python}
#| label: elasticnet-py-print-results
#| echo: false

cv_elastic = pd.read_csv('ml/data/elasticnet-py-results.csv')

prevalence = np.mean(y)
prevalence = np.where(prevalence > 0.5, prevalence, 1 - prevalence)

print(
    'Training accuracy: ',
    np.round(cv_elastic['test_score'].mean(), 3),
    '\nBaseline: ',
    np.round(prevalence, 3),
)
```

##### R

```{r}
#| label: elasticnet-r
#| eval: false
#|

library(mlr3verse)
# library(mlr3learners)
# library(mlr3extralearners)

tsk_elastic = TaskClassif$new(
  id = "heart_disease",
  backend = X_num_df |> drop_na(),
  target = "heart_disease"
)

lrn_elastic = lrn("classif.cv_glmnet", nfolds = 5, type.measure = "class", alpha = 0.5)

cv_elastic = resample(
    task     = tsk_elastic,
    learner    = lrn_elastic,
    resampling = rsmp("cv", folds = 5)
)
```

```{r}
#| label: elasticnet-r-save-results
#| echo: false
#| eval: false

saveRDS(cv_elastic, 'ml/data/elasticnet-r-results.rds')
```


```{r}
#| label: elasticnet-r-print-results
#| echo: false

library(mlr3verse)
library(glue)

cv_elastic = readRDS('ml/data/elasticnet-r-results.rds')

prevalence = mean(df_heart_num$heart_disease)
prevalence = ifelse(prevalence > 0.5, prevalence, 1 - prevalence)

# Evaluate

glue("Training Accuracy: {round(cv_elastic$aggregate(msr('classif.acc')), 3)}\nBaseline Prevalence: {round(prevalence, 3)}")
```

:::





#### Strengths & Weaknesses

##### Strengths

- Intuitive approach.  In the end, it's still just a standard regression model you're already familiar with.
- Widely used for many problems.  Lasso/Ridge/ElasticNet would be fine to use in any setting you would use linear or logistic regression.

##### Weaknesses

- Does not automatically seek out interactions and non-linearity, and as such will generally not be as predictive as other techniques.
- Variables have to be scaled or results will largely reflect data types.
- May have issues with correlated predictors


#### Additional Thoughts

Incorporating regularization would be fine as your default linear model method, and is something to strongly consider for even statistical model settings. Furthermore, these approaches will have better prediction on new data than their standard complements. As such they are a nice balance between staying interpretable while enhancing predictive capability. However, in general they are not going to be as strong of a method as others in the ML universe, and possibly not even competitive without a lot of feature engineering. If prediction is all you care about for a particular modeling setting, you'll likely want to try something else.


## Tree-based methods

Let's move beyond standard linear models and get into a notably different approach. Tree-based methods are a class of models that are very popular in machine learning, and for good reason, they work well. To get a sense of how they are derived, consider the following classification example where we want to predict a binary target as 'Yes' or 'No'. We have two numeric features, $X_1$ and $X_2$. At the start we take $X_1$ and make a split at the value of 5. Any observation less than 5 on $X_1$ goes to the right with a prediction of *No*. Any observation greater than or equal to 5 goes to the left, where we then split based on values of $X_2$, and specifically at 3. Any observation less than 3 goes to the right with a prediction of *Yes*. Any observation greater than or equal to 3 (and greater than or equal to 5 on $X_1$) goes to the left with a prediction of *No*. 

```{r}
#| echo: false
#| eval: false
#| label: tree-graph-setup
g = DiagrammeR::grViz('img/tree.dot')

g %>%
    DiagrammeRsvg::export_svg() %>% charToRaw() %>% rsvg::rsvg_svg("img/tree.svg")
```

```{dot}
//| echo: false
//| eval: false
//| label: tree-graph

# note the //| that apprarently dot requires

digraph tree {
  graph [rankdir = TD  bgcolor="#fffff8"]

  node [shape = rectangle, style=filled, fillcolor=white, color=gray, width=.75]

  node [fontcolor=gray25 fontname=Roboto fixedsize=true fontsize=5]
  X1[width=.25 height=.25 label = <X<sub>1</sub> >];
  X2 [width=.25 height=.25 label = <X<sub>2</sub> >]; 
  No1 [label="No" shape=circle color="#E69F00" width=.25]; 
  No2 [label="No" shape=circle color="#E69F00" width=.33]; 
  Yes [ shape=circle color="#56B4E9" width=.33];

  edge [color=gray50 arrowhead=dot]
  X1 -> No1 [label = " < 5", fontcolor="gray50" fontsize=5.5 color="#E69F00"];
  X1 -> X2 [label = " >= 5", fontcolor="gray50" fontsize=5.5];
  X2 -> No2 [label = " >= 3", fontcolor="gray50" fontsize=5.5 color="#E69F00"];
  X2 -> Yes [label = " < 3", fontcolor="gray50" fontsize=5.5 color="#56B4E9"];
}
```

![A simple classification tree](img/tree.svg){width=50%}

This is a simple example, but it illustrates the basic idea of a tree-based model, where the **tree** reflects the total process, and **branches** the splits going down, ultimately ending at **leaves** where predictions are made. We can think of the tree as a series of if-then statements, where we start at the top and work our way down until we reach a leaf node, which is a prediction for all observations that qualify for that leaf.

If we just had a single tree, this would be the most interpretable model we could probably come up with, and it incorporates nonlinearities (multiple branches on a single feature), interactions (branches across features), and feature selection all in one (some features may not result in useful splits). However, it's unfortunately not a very stable model, and does not generalize well. For example, just a slight change in data, or even just starting with a different feature, might produce a very different tree[^cartbase]. The solution is merely to come up with a bunch of trees, get predictions for each observation from each tree, and then average the predictions. This is the concept behind both **random forests** and **gradient boosting**, which can be seen as different algorithms to produce a bunch of trees, and then average the predictions. They also fall under the heading of **ensemble models**, which are models that combine the predictions of multiple models, in this case individual trees, to ultimately produce a single prediction for each instance.

Random forests and boosting methods are very easy to implement, to a point. However, there are typically a few hyperparameters to consider for tuning. Here are few to think about:

- Number of trees
- Learning rate (GB)
- Maximum **depth** of each tree
- Minimum number of observations in each leaf
- Number of features to consider at each tree/split
- Regularization parameters (GB)
- Out-of-bag sample size (RF)


Those are the ones that you'll usually be trying to figure out via cross-validation for boosting, but there are others. The number of trees and learning rate kind of play off of each other, where more trees allows for a smaller rate[^learningrate], which might work better but will usually take longer to train, but can lead to overfitting if other steps are not taken. The depth of each tree refers to the number of levels down the branches we allow the model to go, as well as how wide we let things get in some implementations. This is important because it controls the complexity of each tree, and thus the complexity of the overall model- less depth helps to avoid overfitting, but too little depth and you won't be able to capture the nuances of the data. The minimum number of observations in each leaf is also important for the same reason. It's also generally a good idea to take a random sample of features (or even data observations) to also help reduce overfitting. The regularization parameters are typically less important in practice, but in general you'll want to use them to reduce overfitting.

[^cartbase]: A single regression/classification tree actually could serve as a decent baseline model, especially given the interepretability.

[^learningrate]: This is pretty much the same concept as in stochastic gradient boosting. Larger learning rates allow for quicker exploration, but may overshoot the optimal value, however defined. Smaller learning rates are more conservative, but may take longer to find the optimal value.


<!-- <img src="img/tree1.png" style="display:block; margin: 0 auto;" width=25%> -->

Here is an example with the heart disease data. Although boosting methods are available in `scikit-learn` for Python, in general we recommend using `lightgbm` or `xgboost` packages directly for boosting implementation, which have a sklearn API anyway (as demonstrated). Also, they both provide R and Python implementations of the package, making it easy to not lose your place when switching between languages.  We'll use `lightgbm` here, but `xgboost` is also a very good option [^nomeow].

[^nomeow]: Some also prefer `catboost`. The authors have not actually been able to practically implement catboost in a setting where it was more predictive or as efficient/speedy as `xgboost` or `lightgbm`, but some have had notable success with it. 

:::{.panel-tabset}

##### Python

```{python}
#| label: boot-py-movies
#| eval: false
#| echo: false

df_movies = pd.read_csv('data/movie_reviews_processed.csv')

X = df_movies.filter(regex='_sc$|genre|release_year_0|season|children_in_home')

X = X.assign(genre=pd.Categorical(X['genre']), season=pd.Categorical(X['season']))

y = df_movies['rating_good']
```


```{python}
#| label: boost-py
#| results: hide
#| eval: false

# potential models you might use
from sklearn.ensemble import HistGradientBoostingClassifier
from lightgbm import LGBMClassifier
from xgboost import XGBClassifier, DMatrix

from sklearn.metrics import accuracy_score

model_boost = LGBMClassifier(
    n_estimators=1000,
    learning_rate=1e-3,
    max_depth = 5,
    verbose = -1
)

cv_boost = cross_validate(
    model_boost,
    df_heart.drop(columns='heart_disease'),
    df_heart_num['heart_disease'],
    cv=5,
    scoring='accuracy',
)  
```

```{python}
#| label: boost-py-save-results
#| echo: false
#| eval: false

pd.DataFrame(cv_boost).to_csv('ml/data/boost-py-results.csv', index=False)
```

```{python}
#| label: boost-py-print-results
#| echo: false

cv_boost = pd.read_csv('ml/data/boost-py-results.csv')

print(
    'Training accuracy: ',
    np.round(np.mean(cv_boost['test_score']), 3),
    '\nBaseline Prevalence: ',
    np.round(prevalence, 3),
)
```

##### R

Note that as of writing, the xgboost package does not support categorical variables in R, so we'll just one-hot encode them.



```{r}
#| eval: false
#| label: boost-r
library(mlr3)
library(mlr3learners)
library(mlr3extralearners)

# Define task
tsk_boost = TaskClassif$new(
  id = "heart",
  backend = X_num_df, #df_heart |> mutate(heart_disease = factor(heart_disease)) ,
  target = "heart_disease"
)

# Define learner
learner_boost = lrn(
  "classif.lightgbm",
  num_iterations = 1000,
  max_depth = 5,
  learning_rate = 1e-3
)

# Cross-validation
cv_boost = resample(
    task       = tsk_boost,
    learner    = learner_boost,
    resampling = rsmp("cv", folds = 5)
)
```

```{r}
#| label: boost-r-save-results
#| echo: false
#| eval: false

saveRDS(cv_boost, "ml/data/boost-r-results.rds")
```

```{r}
#| label: boost-r-print-results
#| echo: false

cv_boost = readRDS("ml/data/boost-r-results.rds")

# Evaluate

glue("Training Accuracy: {round(cv_boost$aggregate(msr('classif.acc')), 3)}\nBaseline Prevalence: {round(prevalence, 3)}")
```

:::


#### Gblinear demo

ADD GBLINEAR BY HAND TO APPENDIX


#### Strengths & Weaknesses

Random forests and boosting methods, though not new, are still 'state of the art' in terms of performance on tabular data like the type we've been using for our demos here. As of this writing, you'll find that it will usually take considerable effort to beat them on tabular data. 

**Strengths**

- A single tree is highly interpretable.
- Easily incorporates features of different types (the scale of numeric features, or using categoricals, doesn't matter).
- Tolerance to irrelevant features.
- Some tolerance to correlated inputs.
- Handling of missing values. Missing values are just another value to potentially split on.

**Weaknesses**

- Honestly few, but like all techniques, it might be relatively less predictive in certain situations. There is [no free lunch](https://machinelearningmastery.com/no-free-lunch-theorem-for-machine-learning/).
- It does take more effort to tune relative to linear model methods.


## Deep Learning and Neural Networks

![](img/nnet.png)

**Deep learning has fundametally transformed the world of data science**. It has been used to solve problems in image recognition, speech recognition, natural language processing, and more, from assisting with cancer diagnosis to summarizing entire novels. Deep learning has also been used to solve problems in tabular data of the kind we've been focusing on. It is not a panacea for every problem, and is not always the best tool for the job, but it is a tool that should be in your toolbox. Here we'll provide brief overview of the key concepts behind them.

### What is a neural network?

Neural networks have actually been around a while. Computationally, since the 80s, and conceptually even much further back. They were not very popular for a long time, but this was mostly a computing limitation, much the same reason Bayesian methods were slower to develop. But now neural networks have recently become the go-to method for many problems. They still can be very computationally expensive, but we at least have the hardware to pull it off now.

At it's core, a neural network can be seen as complex series of matrix multiplications exactly as we've done with a basic linear model. One difference is that neural networks actually implement multiple combinations of features (often referred to as hidden **nodes** or units), and we add in nonlinear transformations between the matrix multiplications. The matrix multiplications are the **linear** part, and the nonlinear transformations are the **activation** part. In fact, you can actually think of neural networks as nonlinear extensions of linear models[^gamnnet]. The linear part is just like a linear model, where we have a set of features, each with a corresponding weight, and we multiply each feature by its weight and sum them up. The activation part is where things get interesting, where we take the output of the linear part and apply a transformation to it, allowing the model to incoporate noninearities.

[^gamnnet]: Regression approaches like GAMs and gaussian process regression can be seen as [approximations to neural networks](https://arxiv.org/abs/1711.00165). This brings us back to having a good baseline. If you know some simpler tools that can approximate more complex ones, you can often get 'good enough' results with the simpler models.

The most common activation function is the **rectified linear unit** or [ReLU](https://en.wikipedia.org/wiki/Rectifier_(neural_networks)). But we could also use the sigmoid function, which is the same as the logistic link function used in logistic regression. In logistic regression, we take the linear combination of features and weights, and then apply the sigmoid function to it. The following shows a logistic regression as a neural network. The input features are $X_1$, $X_2$, and $X_3$, and the output is the probability of a positive outcome. The weights are $w_1$, $w_2$, and $w_3$, and the bias is $w_0$. The sigmoid function is the activation function, and the output is the probability of a positive outcome.


```{r}
#| echo: false
#| eval: false
#| label: logregnn-graph-setup

g = DiagrammeR::grViz('img/logregnn.dot')

g %>%
    DiagrammeRsvg::export_svg() %>% charToRaw() %>% rsvg::rsvg_svg("img/logregnn.svg")
```


```{dot}
//| echo: false
//| eval: false
//| fig-cap: A logistic regression as a neural network
//| label: logistic-nn-graph

digraph neural_network {
  rankdir=LR;
  node [shape=circle color=gray50];
  input_bias[label="bias" fixedsize=True fontsize =6 width=.5];
  X1 [label="X1" fixedsize=True fontsize =6 width=.5];
  X2 [label="X2" fixedsize=True fontsize =6 width=.5];
  X3 [label="X3" fixedsize=True fontsize =6 width=.5];
  
  
  input_bias -> hidden [label=<w<sub>0</sub>> arrowhead="dot" arrowsize=0.5 minlen=.10 fontsize=7];
  X1 -> hidden [label=<w<sub>1</sub>> arrowhead="dot" arrowsize=0.5 minlen=1 fontsize=7];
  X2 -> hidden [label=<w<sub>2</sub>> arrowhead="dot" arrowsize=0.5 minlen=1 fontsize=7];
  X3 -> hidden [label=<w<sub>3</sub>> arrowhead="dot" arrowsize=0.5 minlen=1 fontsize=7];
  hidden [label="H1" fixedsize=True fontsize =10 width=.5 color = "#56B4E9"];
  activation [label="sigmoid" fixedsize=True fontsize =6 width=.5 color = "orange"];
  hidden -> activation [arrowhead="dot" arrowsize=0.5 minlen=1];
  activation -> output [label="" arrowhead="dot" arrowsize=0.5 minlen=1];
  output [label="output" fixedsize=True fontsize =10 width=.5 color=darkred];
}
```


![A logistic regression as a neural network](img/logregnn.svg){width=50%}


#### Getting Started

TODO: ADD LINK TO DATA CHAPTER

For simplicity we'll use the same approach and tools as before, but do know this is probably the very bare minimimum approach for a neural network, and generally you'd prefer on alternative. Too begin with, you'd likely want to tune the architecture a bit. Also, as noted in the data discussion, we'd usually want to use **embeddings** for categorical features as opposed to the one-hot approach used here. For this task, it likely doesn't matter much, but in many you'd prefer the embeddings[^fastaitab].

For our demonstration we'll use sklearn's builtin MLPClassifier and a similar approach using mlr3, which calls pytorch directly under the hood. These provide an easy way to get started with neural networks, and it is a good way to get a sense of how they work. For our example, we'll use the processed data with one-hot encoded features. For our architecture, we'll use three hidden layers with 200 nodes each, and a learning rate of 0.001. We'll also use a validation set of 20% of the data to help with early stopping. We'll also use the **nesterovs momentum** approach, which is a way to help the model avoid local minima. We set an **adaptive learning rate**, which is a way to automatically adjust the learning rate as the model trains. We use a **warm start**, which allows us to train the model in stages, which is useful for early stopping. We'll also set the **validation fraction**, which is the proportion of data to use for the validation set. And finally, we'll use **shuffle** to randomly select observations for each batch.

For the `mlr3` approach we'll use the same architecture, but we'll use the **relu** activation function, which is the same as the rectified linear unit (ReLU) function. We'll also use **adam** as the optimizer, which is a popular choice and the default for the `sklearn` approach also. We'll also use **cross entropy** as the loss function, which is the same as the log loss function used in logistic regression.  We use a **batch size** of 32, which is the number of observations to use for each [batch of training](https://stats.stackexchange.com/questions/153531/what-is-batch-size-in-neural-network). We'll also use **epochs** of 200, which is the number of times to train on the entire dataset. We'll also use **predict type** of **prob**, which is the type of prediction to make. Finally, we'll use **measures** of **logloss** and **accuracy**, which are the metrics to track.


Note that many of these settings are hyperparameters. The values we've chosen are largely arbitrary, and you'd prefer to tune them. 

[^fastaitab]: A really good tool for a standard MLP type approach with automatic embedding is fastai's tabular learner. 


:::{.panel-tabset}

##### Python

```{python}
#| echo: false
#| eval: false
#| label: deep-py-data-setup

X = df_movies.filter(regex='_sc$|genre|release_year_0|season|children_in_home')

X = X.assign(genre=pd.Categorical(X['genre']), season=pd.Categorical(X['season']))

X = pd.get_dummies(X, columns=['genre', 'season'], dtype='int')

y = df_movies['rating_good']
```

```{python}
#| label: deep-py
#| eval: false

from sklearn.neural_network import MLPClassifier

model_mlp = MLPClassifier(
    hidden_layer_sizes=(200, 200, 200),  
    learning_rate='adaptive',
    learning_rate_init=0.001,
    shuffle=True,
    random_state=123,
    warm_start=True,
    nesterovs_momentum=True,
    validation_fraction= .2,
    verbose=False,
)

# with the above settings, this will take a few seconds
cv_mlp = cross_validate(
  model_mlp, 
  X_complete, 
  y_complete, 
  cv=5
) 
```

```{python}
#| echo: false
#| eval: false
#| label: deep-py-save-results

pd.DataFrame(cv_mlp).to_csv('ml/data/deep-py-results.csv', index=False)
```

```{python}
#| label: deep-py-print-results
#| echo: false

cv_mlp = pd.read_csv('ml/data/deep-py-results.csv')

print(
    'Training accuracy: ',
    np.round(np.mean(cv_mlp['test_score']), 3),
    '\nBaseline Prevalence: ',
    np.round(prevalence, 3),
)
```

##### R

```{r}
#| eval: false
#| echo: false
#| label: deep-r-data-setup

X = df_movies %>%
  select(matches("_sc$|genre|release_year_0|season|children_in_home")) |> 
  mutate(
    genre = as.factor(genre),
    season = as.factor(season)
  ) |>
  data.table::as.data.table() |> 
  mltools::one_hot() |> 
  as.matrix()

```

```{r}
#| label: deep-r
#| eval: false

library(mlr3torch)

learner_mlp = lrn(
    "classif.mlp",
    # defining network parameters
    activation = nn_relu,
    layers = 3,
    d_hidden = 200,
    # training parameters
    batch_size = 16,
    epochs = 200,
    # Defining the optimizer, loss, and callbacks
    optimizer = t_opt("adam", lr = 1e-3),
    loss = t_loss("cross_entropy"),
    # # Measures to track
    measures_train = msrs(c("classif.logloss")),
    measures_valid = msrs(c("classif.logloss", "classif.ce")),
    # predict type (required by logloss)
    predict_type = "prob",
    seed = 123
)

tsk_mlp = TaskClassif$new(
    id = "heart",
    backend = X_num_df |> drop_na(),
    target = 'heart_disease'
)

# this will potentially take about a minute
cv_mlp = resample(
    task       = tsk_mlp,
    learner    = learner_mlp,
    resampling = rsmp("cv", folds = 5),
)
```

```{r}
#| label: deep-r-save-results
#| echo: false
#| eval: false

saveRDS(cv_mlp, "ml/data/deep-r-results.rds")
```



```{r}
#| label: deep-r-print-results
#| echo: false

# library(mlr3torch)
cv_mlp = readRDS("ml/data/deep-r-results.rds")

glue('Training Accuracy: {round(cv_mlp$aggregate(msr("classif.acc")), 3)}\nBaseline Prevalence: {round(prevalence, 3)}')
```


:::


#### Strengths & Weaknesses

**Strengths**

- Good prediction generally.
- Incorporating the predictive power of different combinations of inputs.
- Some tolerance to correlated inputs.

**Weaknesses**

- Susceptible to irrelevant features.
- Not robust to outliers.
- Generally doesn't outperform with tabular data.

## A Tuned Example

As we noted in the chapter on machine learning concepts, there are typically multiple hyperparamteres we are concerned with. For the linear model, we might want to tune the penalty parameter and the mixing ratio.For a boosting method, we might want to tune the number of trees, the learning rate, the maximum depth of each tree, the minimum number of observations in each leaf, and the number of features to consider at each tree/split. And for a neural network, we might want to tune the number of hidden layers, the number of nodes in each layer, the learning rate, the batch size, the number of epochs, and the activation function. And so on.

Here is an example using the boosted model from before. We'll use the same data and settings as before, but we'll tune the number of trees, the learning rate, and the maximum depth of each tree. We'll use a **randomized search** approach, which is a way to randomly sample from a set of hyperparameters. Rather than searching every possible combination. This is a good approach when you have a lot of hyperparameters to tune, and/or when you have a lot of data.

:::{.panel-tabset}

##### Python

```{python}
#| label: tune-boost-py
#| eval: false
#| results: hide

from sklearn.model_selection import RandomizedSearchCV, train_test_split
from sklearn.metrics import accuracy_score

from lightgbm import LGBMClassifier

# train-test split
X_train, X_test, y_train, y_test = train_test_split(
    df_heart.drop(columns='heart_disease'), df_heart_num['heart_disease'], test_size=0.2, random_state=42
)

model_boost = LGBMClassifier(
    verbose = -1
)

param_grid = {
    'n_estimators': [500, 1000],
    'learning_rate': [1e-3, 1e-2, 1e-1],
    'max_depth': [3, 5, 7, 9],
    'min_child_samples': [1, 5, 10],
}

# this will take a few seconds
cv_boost_tune = RandomizedSearchCV(
    model_boost, 
    param_grid, 
    n_iter = 10,
    cv=5, 
    scoring='accuracy', 
    n_jobs=-1
)

cv_boost_tune.fit(X_train, y_train)
```

```{python}
#| label: tune-boost-py-save-results
#| echo: false
#| eval: false
#| results: hide

test_predictions = cv_boost_tune.predict(X_test)
pd.DataFrame(cv_boost_tune.cv_results_).to_csv('ml/data/tune-boost-py-results.csv', index=False)
pd.DataFrame(test_predictions).to_csv('ml/data/tune-boost-py-predictions.csv', index=False)
```

```{python}
#| label: tune-boost-py-print-results
#| echo: false

from sklearn.model_selection import RandomizedSearchCV, train_test_split
from sklearn.metrics import accuracy_score

X_train, X_test, y_train, y_test = train_test_split(
    df_heart.drop(columns='heart_disease'), df_heart_num['heart_disease'], test_size=0.2, random_state=42
)

df_cv_boost_tune = pd.read_csv('ml/data/tune-boost-py-results.csv')
test_predictions = pd.read_csv('ml/data/tune-boost-py-predictions.csv')

print(
    # 'Training accuracy: ',
    # np.round(df_cv_boost_tune['mean_test_score'].mean(), 3),
    '\nTest Accuracy',
    np.round(accuracy_score(y_test, test_predictions), 3),
    '\nBaseline Prevalence: ',
    np.round(prevalence, 3),
)
```

##### R

```{r}
#| label: tune-boost-r
#| eval: false

# train test split

set.seed(123)

library(mlr3verse)
library(rsample)

split = initial_split(X_num_df, prop = .75)

df_train = training(split)
df_test  = testing(split)

tsk_lgbm_tune = as_task_classif(
    df_train,
    target = "heart_disease"
)

lrn_lgbm_tune = lrn(
    "classif.lightgbm",
    num_iteration = to_tune(c(500, 1000)),
    learning_rate = to_tune(1e-3, 1e-1),
    max_depth = to_tune(c(3, 5, 7, 9)),
    min_data_in_leaf = to_tune(c(1, 5, 10))
)

# set up the validation process
instance_lgbm_tune = ti(
    task = tsk_lgbm_tune,
    learner = lrn_lgbm_tune,
    resampling = rsmp("cv", folds = 5),
    measures = msr("classif.acc"),
    terminator = trm("evals", n_evals = 10)
)

# instance
tuner = tnr("random_search")

tuner$optimize(instance)
```

```{r}
#| echo: false
#| eval: false
#| label: tune-boost-r-save-results

# as.data.table(lrn("classif.lightgbm")$param_set)  |> pull(id)

save(
    instance,
    tuner, 
    df_train,
    df_test,
    file = "ml/data/tune-boost-r-results.RData"
)
```

```{r}
#| label: tune-boost-r-print-results
#| echo: false

load("ml/data/tune-boost-r-results.RData")

# Evaluate
# as.data.table(instance$archive)

library(mlr3verse)

autoplot(instance) # this is good to show 

tsk_lgbm_tune = as_task_classif(
    df_train,
    target = "heart_disease"
)

lrn_lgbm_tuned = lrn("classif.lightgbm")
lrn_lgbm_tuned$param_set$values = instance$result_learner_param_vals
lrn_lgbm_tuned$train(tsk_lgbm_tune)

test_preds = lrn_lgbm_tuned$predict_newdata(df_test) 
test_acc = msr("classif.acc")$score(test_preds)

glue("Test Accuracy: {round(test_acc, 3)}\nBaseline Prevalence: {round(prevalence, 3)}")
```


:::

## Compare models

Let's compare the results of our models head to head. In general, our fastest/best results were the elastic net and boosting models, though not by much for this data set. This is not surprising. Even the simplest neural network takes notable effort to do well, and often longer to train. And while we would definitely use deep learning tools for image classification, natural language processing and other domains, they still struggle to do consistently as well as boosting for the type of data we've been using. In general though, this was a good example of having an adequate baseline and where complexity didn't really help much, though all our approaches did well.



```{python}
#| label: tune-boost-py-init
#| eval: false
#| echo: false
from strong_tabular.model import fit_model
from strong_tabular.metrics import make_binary_metric
from sklearn.metrics import accuracy_score, roc_auc_score

init = df_heart.assign(heart_disease = np.where(df_heart['heart_disease'] == 'yes', 1, 0))

tuned_boost = fit_model(
    init, 
    'heart_disease', 
    objective = 'binary', 
    max_min = 'maximize', 
    metric = make_binary_metric(accuracy_score),
    max_num_rounds = 1000
)

# tuned_boost['best_trial'].values
# tuned_boost['test_performance']
# tuned_boost['importance']
```


:::{.panel-tabset}

##### Python

```{python}
#| label: compare-py
#| echo: false

cv_results = pd.concat(
    [
        pd.read_csv('ml/data/elasticnet-py-results.csv').assign(model = 'elasticnet'),
        pd.read_csv('ml/data/boost-py-results.csv').assign(model = 'boost'),
        # pd.read_csv('ml/data/tune-boost-py-results.csv')[['mean_fit_time', 'mean_score_time', 'mean_test_score']].assign(model = 'boost_tuned').rename(columns={'mean_fit_time': 'fit_time', 'mean_score_time': 'score_time', 'mean_test_score': 'test_score'}),
        pd.read_csv('ml/data/deep-py-results.csv').assign(model = 'nnet'),
        
    ]
)

(
    cv_results
    .groupby('model', as_index=False)
    .mean()
    .round(2)
    .drop(columns='score_time')
    .rename(columns={'test_score': 'val. acc.'})
)
```

##### R

```{r}
#| label: compare-r
#| echo: false

# attempted to get times but don't think they are saved
fnames = list.files('ml/data', pattern = 'results.rds', full.names = TRUE) 
fnames = fnames[!grepl('tune', fnames)]

cv_results = fnames |> 
  map(readRDS) |> 
  map_dfr(\(x) x$aggregate(msr('classif.acc'))) |> 
  mutate(model = str_remove(basename(fnames), '-r-results.rds'))

cv_results |>
    select(model, everything()) |> 
    arrange(desc(classif.acc)) |> 
    gt(decimals = 2)
```

:::

Also, our tuned results showed that we could get a bit better performance with a bit more effort. For Python and R our results on a holdout set were about as good or even better with the tuned model.

## ANOTHER SECTIONS

was going to briefly cover something but now forgotten after dealing with tuning/saving problems

## Other ML Models

When you look up models used in classical machine learning applied to data of the type we've been exploring, you'll potentially see a lot of different kinds.  Popular methods from the past include *k*-nearest neighbors, support vector machines, and more. You don't see these used in practice much though, as these have mostly been made obsolete due to not being as predictive as other options in general (k-nn), or maybe only working well with 'pretty' data situations (SVM), or just being less interpretable. While they might work well in certain situations, when you have tools that can handle a lot of data complexity and predict very well (and typically better) like tree-based methods, there's not much reason to use the historical alternatives these days. If you're interested in learning more about them or think one of them is just 'neat'[^svm], you could potentially use it as a baseline model. Alternatively, you could maybe employ them as part of an ensemble model, where you combine the predictions of multiple models to produce a single prediction. This is a common approach in machine learning, and is often used in Kaggle competitions. We won't go into detail here, but it's worth looking into if you're interested. There are also many other methods that are more specialized, such as those for text, image, and audio data.  We will provide an overview of these in another chapter.


## Exercise


[^svm]: Mathy folk should love SVMs.




## refs

RadfordM.Neal.Priorsforinfinitenetworks(tech.rep.no.crg-tr-94-1).UniversityofToronto, 1994a. https://arxiv.org/abs/1711.00165

https://en.wikipedia.org/wiki/Activation_function

https://stats.stackexchange.com/questions/164876/what-is-the-trade-off-between-batch-size-and-number-of-iterations-to-train-a-neu