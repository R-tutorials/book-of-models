---
title: "Generalized Linear Models"
always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, error = FALSE, comment = "")
```

What happens when your target variable isn't really a continuous variable, but is instead some other type of response. Maybe you've got a binary condition, like good or bad, or maybe you've got a count of something, like the number of times a person has been arrested. In these cases, you can't use a linear regression, but you can use a generalized linear model. 

Generalized linear models exist to map different distributions into linear space. This allows us to use the same linear model framework that we've been using, but with different types of data.

These models work by **generalizing** the linear model to different distributions of the target variable. Our coefficients will certainly take on a new meaning; so while we cannot interpret them as we would coefficients from a linear regression, we can still use the general framework.

## Distributions & Link Functions

Remember how linear models really enjoy the whole Gaussian distribution scene? The essential form of the linear model can be expressed as follows:

$$y \sim Normal(\mu,\sigma) \\ \mu = \alpha + \beta X$$

Not all data follows a Gaussian distribution. Instead, we often find some other form of an exponential distribution. So, we need a way to incorporate different distributions of the target into our model. Distributions cannot do it alone! We also need a **link function** to connect the linear model to the distribution.

From a theoretical perspective, link functions are tricky to get your head around.

- *Find the exponential of the response's density function and derive the canonical link function*...

From a conceptual perspective, all they are doing is allowing the linear feature to "link" to a distribution function's mean. If you know a distribution's canonical link function, that is all the deeper you will probably every need.

At the end of the day, these link functions will convert the target to an unbounded continuous variable. The take-away here is that the link function describes how the mean is generated from the predictors.

## Logistic Regression

### Why Should You Care

You will often have a binary variable that you might want to use as a target -- it could be dead/alive, lose/win, quit/retain, etc. You might be tempted to use a linear regression, but you will quickly find that it is not the best option. You are going to be figuring out the probability of moving from "failure" to "success", given the features in your model.

### The Binomial Distribution

Logistic regression is substantially different than linear regression. It is also a bit confusing, because it is named after its link function (**logit**) instead of its distribution (**binomial**). Instead of that nice continuous target, we are dealing with a binomially-distributed target and the target takes the form of a binary variable. 

We don't have a $\mu$ or $\sigma^2$ to identify the shape of the binomial distribution; instead we have *p* and *n*, where *p* is a probability and *n* is the number of trials. We tend to talk about *p* with regard to the probability of a specific event happening (heads, wins, defaulting, etc.).

Let's see how the binomial distribution looks with 100 trials and probabilities of "success" at *p = * .25, .5, and .75:

```{r}
library(ggplot2)

library(dplyr)

binom.25 <- dbinom(1:100, size = 100, prob = .25)

binom.5 <- dbinom(1:100, size = 100, prob = .5)

binom.75 <- dbinom(1:100, size = 100 , prob = .75)

as.data.frame(rbind(binom.25, binom.5, binom.75)) %>% 
  mutate(prob = row.names(.)) %>% 
  tidyr::gather(., "key", "value", -prob) %>% 
  mutate(key = as.numeric(gsub("V", "", key))) %>% 
  ggplot(., aes(x = key, y = value, fill = prob)) + 
  geom_col(alpha = .5) + 
  scale_fill_brewer(type = "qual", palette = "Dark2") + 
  theme_minimal()
```

If we examine the distribution for a probability of .5 (the orange bars titled "binom.5"), we will see that it is centered over 50 -- this would suggest that we have the highest probability of encountering 50 successes if we ran 100 trials. If we run 100 trials 100 times and the outcome is 50/50, the most common outcome from those 100 trials would be 50 successes. with a decreasing probability of observing more or less successes as we move away from 50. Shifting our attention to a .75 probability of success, we see that our density is sitting over 75. Again running 100 trials, would give us the highest probability of observing 75 successes. Some of those 100 trials produce more or less than 75 successes, but with lower probabilities as you get further away from 75.

Since we are dealing with a number of trials, it is worth noting that the binomial distribution is a discrete distribution. If you have any interest in knowing the probability for a number of success under the binomial distribution, we can use the following formula:

$$P(x) = \frac{n!}{(n-x)!x!}p^xq^{n-x}$$

While we don't need to dive into finding those specific values for the binomial distribution, we can spend our time exploring how it looks in linear model space:

$$y \sim Binomial(n, p) \\ logit(p) = \alpha + \beta X$$

The *logit* function is defined as:

$$log\frac{p}{1-p}$$

We are literally just taking the log of the odds (the log odds becomes important later).

Now we can map this back to our model:

$$log\frac{p}{1-p} = \alpha + \beta X$$

And finally we can take that logistic function and invert it (the **inverse-logit**) to produce the probabilities.

$$p = \frac{exp(\alpha + \beta X)}{1 + exp(\alpha + \beta X)}$$

Whenever we get coefficients for the logistic regression model, we are always going to get them as log odds. We can exponentiate them to get the odds ratio, but we can also exponentiate them and divide by 1 + that value to get the probability.

### Probability, Odds, and Log Odds

Probability lies at the heart of all of this.  We can look at the relationship between the probability, odds, and log odds.

```{r}
probabilityList <- seq(.001, .999, by = .01)
```

We have a list of probability values (always between 0 and 1).  Now, let's write a function to convert them to odds. We will use the $\\p\, / 1 - p$ equation.

```{r}
oddsConversion <- function(p) {
  res = p / (1 - p)
  return(res)
}

odds <- oddsConversion(probabilityList)

plot(log(odds), odds)
```

Now, we can convert them to log odds:

```{r}
plot(log(odds), probabilityList)
```

If you've ever seen this sigmoid before, it is the classic logistic function.

We can clearly go back and forth between the 3, but the main message here is that we took a bounded variable in probability and transformed it to continuous space.

We will see more about how this happens after playing with the model.

### Data Import and Preparation

We are going to return to our movie reviews data and we are going to use `rating_good` as our target. Before we get to modeling, see if you can find out the frequency of "good" and "bad" reviews. We will use `word_count` and `gender` as our predictors. Before we move on, though, find the probability of getting a "good" review.

:::{.panel-tabset}

##### R

```{r}
reviews <- read.csv("data/movie_reviews_processed.csv")
```

```{r}
X <- reviews[, c("word_count", "gender")]

X = cbind(1, X)

X$gender <- ifelse(X$gender == "male", 1, 0)

X <- as.matrix(X)

y <- reviews$rating_good
```

##### Python

```{python}
import pandas as pd

reviews = pd.read_csv("data/movie_reviews_processed.csv")
```

```{python}
X = reviews[['word_count', 'gender']]

X = pd.DataFrame(
  {'intercept': 1, 
  'word_count': reviews['word_count'], 
  'gender': reviews['gender']}
)

y = reviews["rating_good"]
```

:::

### Standard Functions

To get started with our first logistic regression model, let's use the `glm` function from R and Python's `statsmodels` function.

:::{.panel-tabset}

##### R

```{r}
logistic_regression <- glm(
    rating_good ~ word_count + gender, 
    data = reviews,
    family = binomial
)

summary(logistic_regression)
```

##### Python

```{python}
import statsmodels.api as sm

logistic_regression = sm.Logit(y, X).fit()

logistic_regression.summary()
```

### Interpretation and Visualization

We need to know what those results mean. The coefficients that we get from our model are in log odds. We can exponentiate them to get the odds ratio, but we can also exponentiate them and divide by 1 + that value to get the probability. Interpretting log odds is a fool's errand, but we can at least get a feeling for them directionally. A log odds of 0 would indicate no relationship between the feature and target. A positive log odds would indicate that an increase in the feature will increase the log odds of moving from "bad" to "good", whereas a negative log odds would indicate that a decrease in the feature will decrease the log odds of moving from "bad" to "good". We can convert those log odds to help make some more sense from them.

When we exponentiate the log odds coefficients, we are given the odds ratio.  This is the ratio of the odds of the outcome (i.e., success from our binomial distribution) occurring for a one unit increase in the predictor. 

```{r}
exp(logistic_regression$coefficients)
```

Fortunately, the intercept is easy -- it is the odds of a "good" review when word count is 0 and gender is "female". We see that we've got an odds ratio of .86 for the word_count variable and 1.12 for the male variable. An odds ratio of 1 means that there is no change in the odds of the outcome occurring -- essentially that the predictor does not influence the target. An odds ratio of less than 1 means that the odds of the outcome occurring decrease as the predictor increases (while a bit more complicated to wrap your head around, it captures the idea of the odds of moving from a "bad" review to a "good" review decreasing). An odds ratio of greater than 1 means that the odds of the outcome occurring increase as the predictor increases (again, the odds of moving from a "bad" review to a "good" review increasing).

It is far more intuitive to interpret the probability.  We can do this by exponentiating the coefficients and dividing by 1 + that value.  This will give us the probability of the outcome occurring for a one unit increase in the predictor.

```{r}  
exp(logistic_regression$coefficients) / (1 + exp(logistic_regression$coefficients))
```

We would say that our probability of moving from a "bad" review to a "good" review is .84 when there are 0 words in the review and the gender is female. Since word_count is below .5, we know that it will have a negative relationship with the probability of moving from "bad" to "good"; being a male reviewer will have a positive relationship with the probability of moving from "bad" to "good".

And visualizing those probabilities is absolutely the best way to see how the features influence the target:

```{r}
library(sjPlot)

plot_model(logistic_regression, type = "pred", terms = "word_count") +
    theme_minimal()
```

For word_count, we can see a clear negative relationship between the number of words in a review and the probability of being considered a "good" movie. As we get over 20 words, the predicted probability of being a "good" movie is less than .2. 

```{r}
plot_model(logistic_regression, type = "pred", terms = "gender") +
    theme_minimal()
```

There are interesting issues at play here with regard to our predictor coefficients (what can be considered a *relative effect*) and the model's effect as a whole on the probability (the *absolute effect*). In circumstances where the intercept is very large (essentially promising a success), the relative effect of a coefficient is practically meaningless. Similarly, very negative coefficients render the relative effects useless. 

### Loss Function

Let's see how we can pick that work apart to create our own functions. We can use maximum likelihood estimation to estimate the parameters of our model.  

:::{.panel-tabset}

##### R
```{r}
logreg_ml <- function(par, X, y) {
  # Arguments
  # par: parameters to be estimated
  # X: predictor matrix with intercept column
  # y: target
  
  # setup
  beta = par                                # coefficients
  N = nrow(X)
  
  # linear predictor
  LP = X %*% beta                           # linear predictor
  mu = plogis(LP)                           # logit link
  
  # calculate likelihood
  L = dbinom(y, size = 1, prob = mu, log = TRUE)         # log likelihood
  #   L =  y*log(mu) + (1 - y)*log(1-mu)    # alternate log likelihood form
  
  -sum(L)                                   # optim by default is minimization, and we want to maximize the likelihood 
  # (see also fnscale in optim.control)
}
```

##### Python

```{python}
def logreg_ml(par, X, y):
    # Arguments
    # par: parameters to be estimated
    # X: predictor matrix with intercept column
    # y: target
    
    # setup
    beta = par                                # coefficients
    N = X.shape[0]
    
    # linear predictor
    LP = X.dot(beta)                          # linear predictor
    mu = 1 / (1 + np.exp(-LP))                # logit link
    
    # calculate likelihood
    L = y*np.log(mu) + (1 - y)*np.log(1-mu)   # log likelihood
    
    return -np.sum(L)   
```

### Model Fitting

Now that we have our loss function, we can fit our model.  We will use the `optim` function in R and the `minimize` function in Python.

:::{.panel-tabset}

##### R

```{r}
init = rep(0, ncol(X))

names(init) = c('intercept', 'b1', 'b2')

fit_ml = optim(
  par = init,
  fn  = logreg_ml,
  X   = X,
  y   = y,
  control = list(reltol = 1e-8)
)

pars_ml = fit_ml$par

pars_ml
```

##### Python

```{python}
from scipy.optimize import minimize

init = np.zeros(X.shape[1])

fit_ml = minimize(
    fun = logreg_ml,
    x0 = init,
    args = (X, y),
    method = 'BFGS',
    options = {'disp': True}
)
```

:::{.callout-important}
In theory, there is no such thing as 0 or 1 probability. When your model encounters such a value, you will receive a warning, not an error. The most likely cause of this warning is **separation**: a variable is perfectly separating the target. In other words, once a feature gets below/above a certain value, the target is always 0/1. While that variable is no doubt valuable, it can't be used in a logistic regression model. More evidence of separation comes when you see your log odds coefficients return something comically large. 
:::

:::{.callout-warning}
Logistic regression does not have an $R^2$ value in the way that a linear regression model does. Instead, there are pseudo-$R^2$ values, but they are not the same as the $R^2$ value that you are used to seeing. <a href="https://stats.idre.ucla.edu/other/mult-pkg/faq/general/faq-what-are-pseudo-r-squareds/">Here</a> is a great breakdown of different pseudo methods.
:::

## Poisson Regression

### Why Should You Care

Like logistic regression, poisson regression belongs to a broad class of generalized linear models. Poisson regression is used when you have a count variable as your target. The nature of a count variable is very different, since it starts at 0 and can only be a whole number. We need a model that will not produce negative predictions and poisson regression will do that for us.

### The Poisson Distribution

The Poisson distribution is very similar to the binomial distribution, but has some key differences. The biggest difference is in its parameter: Poisson has a single parameter noted as $\lambda$. This rate parameter is going to estimate the expected number of events during a time interval. This can be accidents in a year, pieces produced in a day, or hits during the course of a baseball season. We can find the rate by determining the number of events per interval, multiplied by the interval length.

$$\frac{\text{event}}{\text{interval}}*\text{interval length} $$

To put some numbers to that, if we have 1 accident per week in a factory and we are observing a whole year, we would get the following rate:

```{r}
(1 / 7) * 28
```

We expect about 4 accidents over the course of a month.

Let's see what that particular distribution might look like:

```{r}
ggplot(data.frame(x = 0:20), aes(x)) +
  geom_col(aes(y = dpois(x, (1 / 7) * 28)), fill = "#ff5500") +
  theme_minimal()
```

We can also see what it looks like for different rates (some places might be safer than others):

```{r}
ggplot() +
  geom_col(data = data.frame(x = 1:28, y = dpois(1:28, (1 / 7) * 28)),
           mapping = aes(x, y), width = .97, alpha = .25, fill = "red") +
  geom_col(data = data.frame(x = 1:28, y = dpois(1:28, (3 / 7) * 28)),
           mapping = aes(x, y), width = .97, alpha = .25, fill = "blue") +
  geom_col(data = data.frame(x = 1:28, y = dpois(1:28, (5 / 7) * 28)),
           mapping = aes(x, y), width = .97, alpha = .25, fill = "green") +
  theme_minimal()
```


:::{.callout-note}
A cool thing about these distributions is that they can deal with different *exposure* rates. You don't need observations recorded over the same interval length, because you can adjust for them appropriately. They can also be used to model inter-arrival times and time-until events.
:::



## The (Sometimes) Thin Line

This gets into an area where we need to think long and hard about our dependent variable and what it actually might be. Since Poisson regression gets its name from the Poisson distribution, we should probably see if it follows the Poisson distribution.

```{r}
library(vcd)

poissonTest <- goodfit(reviews$total_reviews, type = "poisson")

summary(poissonTest)
```

This is a $\chi^2$ to test if the distribution deviates from a Poisson. If we see a significant value, we would say that it deviates from the tested distribution. In this case, everything looks okay.


We can also plot that test using a hanging rootogram:

```{r}
plot(poissonTest)
```

The bars are the observed counts and the red line/points are the fitted counts (i.e., how many would be expected). If a bar does not reach the 0 line, then the model would over-predict for that particular count; if the bar dips below the 0 line, the model under-predicts that count.

### Dispersion

For models of this nature (our dependent variable is a count variable), we may have two different distributions with which to operate: the Poisson distribution or the negative binomial distribution.

Let’s check this out (it will be important later on!).

```{r}
shroudData[, list(mean = mean(shroudsProduced), 
                  var = var(shroudsProduced)), 
           by = employeeCount]
```

What is the purpose of this? We are checking the conditional means and variances. Why is this important? If our variances are larger than our means, we have *overdispersion*. We would expect values to be equally distributed over levels, but if they are really spread out, this qualifies as overdispersion – this is not good for our Poisson model because it will cause downward bias.

As an overly simple check, we can also compare the mean and the variance of our outcome variable -- they should be close to equal!

```{r}
mean(shroudData$shroudsProduced)

var(shroudData$shroudsProduced)
```

Not terribly far off, but we will see if it becomes a problem later. You might be wondering why overdispersion is a problem -- it goes back to the single parameter within the Poisson distribution. The normal distribution has a parameter for dealing with variance -- $\sigma$ -- Poisson does not, so the assumption is that any variance would be equal to the mean.

### Standard Functions

Recall that every distribution has a link function (or several) that tend to work well for it. The poisson distribution uses a log link function:

$$y = Poisson(\lambda) \\ \text{log}(\lambda) = \alpha + \beta X$$

Using the log link keeps the outcome positive (we cannot deal with negative counts). Logs, as they are prone to do, are going to tend towards an exponential relationship; just be sure that it makes sense over the entire range of your data.

```{r}
poissonTest <- glm(shroudsProduced ~ employeeCount,
                  data = shroudData,
                  family = poisson)

summary(poissonTest)

exp(poissonTest$coefficients)
```

**Important Note:** We are going to interpret this almost the same as a linear regression. The slight wrinkle here, though, is that we are looking at the log counts (remember that we specified the log link function). In other words, an increase in one employee leads to an expected log count increase of ~.029. Just like our logisitc regression, we could exponentiate this to get 1.029189 – every employee we add gets us a ~3% increase in shrouds produced. Let’s see what this looks like in action:

```{r}
shroudData <- shroudData %>%
  mutate(predValues = predict(poissonTest, type = "response"))

ggplot(shroudData, aes(employeeCount, predValues)) +
  geom_count() +
  scale_size_area() +
  theme_minimal()
```


```{r}
pchisq(poissonTest$deviance, poissonTest$df.residual, lower.tail = FALSE)
```

With everything coupled together, we have a meaningful coefficient, a clear plot, and adequate model fit. Therefore, we might conclude that there is a positive relationship between number of employees on shift and shrouds produced.

In addition to checking our data for over dispersion before running the model, we can also check it after running our model:

```{r}
library(AER)

dispersiontest(poissonTest)
```

The dispersion value that we see returned (0.9452052 in our case) should be under 1. A dispersion value over 1 means that we have overdispersion. Our dispersion value, coupled with our high *p*-value, indicates that we would fail to reject the null hypothesis of equidispersion.

We can also look back to our model results to compare our residual deviance to our residual deviance degrees of freedom; if our deviance is greater than our degrees of freedom, we might have an issue with overdispersion. Since we are just a bit over and our overdispersion tests do not indicate any huge issue, we can be relatively okay with our model. If we had some more extreme overdispersion, we would want to flip to a quasi-poisson distribution -- our coefficients would not change, but we would have improved standard errors.

### Model Specification

:::{.panel-tabset}

##### R

```{r}
zip_ll <- function(y, X, par) {
  # arguments are response y, predictor matrix X, and parameter named starting points of 'logit' and 'pois'
  
  # Extract parameters
  logitpars = par[grep('logit', names(par))]   
  poispars  = par[grep('pois', names(par))]     
  
  # Logit part; in this function Xlogit = Xpois but one could split X argument into Xlogi and Xpois for example
  Xlogit  = X
  LPlogit = Xlogit %*% logitpars
  logi0   = plogis(LPlogit)  # alternative 1/(1+exp(-LPlogit))
    
  # Poisson part
  Xpois  = X
  mupois = exp(Xpois %*% poispars)
  
  # LLs
  logliklogit = log( logi0 + exp(log(1 - logi0) - mupois) )
  loglikpois  = log(1 - logi0) + dpois(y, lambda = mupois, log = TRUE)
  
  # Hilbe formulation
  # logliklogit = log(logi0 + (1 - logi0)*exp(- mupois) )
  # loglikpois = log(1-logi0) -mupois + log(mupois)*y     #not necessary: - log(gamma(y+1))
    
  y0 = y == 0  # 0 values
  yc = y > 0   # Count part

  loglik = sum(logliklogit[y0]) + sum(loglikpois[yc])
  -loglik
}
```

##### Python

:::

### Starting Values

:::{.panel-tabset}

##### R

```{r}
initial_model = glm(
  count ~ persons + livebait,
  data = fish,
  x = TRUE,
  y = TRUE,
  "poisson"
)

# starts = c(logit = coef(initial_model), pois = coef(initial_model))  
starts = c(rep(0, 3), rep(0, 3))

names(starts) = c(paste0('pois.', names(coef(initial_model))),
                  paste0('logit.', names(coef(initial_model))))
```

##### Python

:::

### Model Fitting

:::{.panel-tabset}

##### R

```{r}
fit = optim(
  par = starts ,
  fn  = zip_ll,
  X   = initial_model$x,
  y   = initial_model$y,
  method  = "BFGS",
  control = list(maxit = 5000, reltol = 1e-12),
  hessian = TRUE
)
```


##### Python

:::

## Wrapping Up

These are just two of the many models that fall under the broad umbrella of generalized linear models. Depending on your data situation, you might want to keep the following in find:

```{r}
model_df <- data.frame(distribution = c("beta", ), 
                      target = c("proportion", ))
```

