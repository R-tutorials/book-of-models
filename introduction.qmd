# Introduction

```{r}
library(tidyverse)
library(reticulate)
use_condaenv('book-of-models')
options(digits=2)
```

Regardless of background, and whether we're conscious of it or not, we are constantly inundated with data. It's inescapable, from our first attempts to understand the world around us, to our most recent efforts to explain why we still don't get it. Even now, our most complicated and successful models are almost uninterpretable even to those that created them. But that doesn't mean that even in those cases we can't understand the essence of how they work. And if you're reading this, you are probably the type of person that wants to keep trying! So for seasoned professionals or perhaps just the data curious, we want to help you learn more about how to use data to answer the questions you have. 

## What Is This Book?

This book is a practical resource, something we hope you can refer to for a quick overview of a specific modeling technique, a reminder of something you've seen before, or perhaps a sneak peak into some modeling details. The text is focused on a few statistical and machine learning approaches that are widely employed, and specifically those which form the basis for most other models in use. Believe it or not, whether a lowly t-test or a complex neural network, there is a tie that binds. We hope to help you understand some of the core modeling principles, and how the simpler models can be extended and applied to a wide variety of data scenarios.

Our approach here is first and foremost a practical one, as models themselves are just tools to help us reach a goal. If a model doesn't work in the world, it's not very useful. But modeling often is also a delicate balance of interpretation and prediction, and each data situation is unique in some way, requiring a bespoke approach. What works well in one setting may be poor in another, and what may be the state of the art may only be marginally better than a notably simpler approach that is far more interpretable. In addition, complexities arise even in an otherwise deceptively simple application. However, if you have the core understanding of the techniques that lie at the heart of many models, you'll automatically have many more tools at your disposal to tackle the problems you face, and be more comfortable with choosing the best for your needs.  

## Who Should Use This Book?

This book is intended for every type of *data dabbler*, no matter what part of the data world you call home. If you consider yourself a data scientist, a business analyst, or a statistical hobbyist, you already know that the best part of a good dive into data is the modeling. But whatever your data persuasion, models give us the possibility to answer questions, make predictions, and understand what we're interested in a little bit better. And no matter who you are, it isn't always easy to understand *how the models work*. Even when you do get a good grasp of a modeling approach, it can still get complicated, and there are a lot of details to keep track of. In other cases, maybe you just have other things going on in your life and have forgotten a few things. We find that it's always good to remind yourself of the basics! So if you're just interested in data and hoping to understand it a little better, then it's likely you'll find something useful in this book!

Your humble authors have struggled mightily themselves throughout the course of their data history, and still do! We were initially taught by those that weren't exactly experts, and often found it difficult to get a good grasp of statistical modeling and machine learning. We've had to learn how to use the tools, how to interpret the results, and possibly the most difficult, how to explain what we're doing to others! We've forgotten a lot, confused ourselves, and made some happy accidents in the process. That's okay! Our goal here is to help you avoid some of those pitfalls, help you understand the basics of how models work, and get a sense of how most modeling endeavors have a lot of things in common. 

As an example, let's look at the different ways we might express a relationship. Here is a formula for the Pearson-Product-Moment correlation coefficient:

$$
\rho = \frac{\Sigma(x_i-\bar{x})(y_i-\bar{y})}{\sqrt{\Sigma(x_i-\bar{x})^2\Sigma(y_i-\bar{y})^2}}
$${#eq-pearson}

Here is some code to calculate the Pearson-Product-Moment correlation coefficient by hand:

:::{.panel-tabset}

############ R

```{r}
my_cor <- function(x, y) {
  x_bar <- mean(x)
  y_bar <- mean(y)
  numerator <- sum((x - x_bar) * (y - y_bar))
  denominator <- sqrt(sum((x - x_bar)^2) * sum((y - y_bar)^2))
  numerator / denominator
}
```

############ Python

```{python}
def my_cor(x, y):
    x_bar = np.mean(x)
    y_bar = np.mean(y)
    numerator = np.sum((x - x_bar) * (y - y_bar))
    denominator = np.sqrt(np.sum((x - x_bar)**2) * np.sum((y - y_bar)**2))
    numerator / denominator
``` 
:::

Here is some code to get a correlation how we might typically do it.

```{r}
#| echo: false
#| results: "hide"
df = mgcv::gamSim(n = 100)
x <- df$x2
y <- df$y
```

```{r}
cor(x, y, method = "pearson")
my_cor(x, y)
```

and here in @fig-simple-corr is a plot of the relationship between two variables[^badcor].

[^badcor]: The visualization reveals that the standard Pearson correlation coefficient is not the best choice for this relationship. 

```{r simple-corr}
#| echo: false
#| fig-cap: 'Example relationship between two variables.'
#| label: fig-simple-corr
#| out.width: '100%'
#| fig.width: 3

ggplot(data = tibble(x, y), aes(x = x, y = y)) +
  geom_point() +
  geom_smooth(se = FALSE)
```

Whether you enthusiastically poured over the formula or pretended like you didn't see it and skipped over it, we promise that you don't need to memorize this formula to interpret the a correlation.  We are the first to admit that we have long dumped the ability to pull formulas out of our brain folds[^formulas]; however, knowing how those individual pieces work together only helps to deepen your understanding of the model. Typically using code puts the formula into more concrete terms that you can then use in different ways to solidify and expand your knowledge. Sometimes you just need a reminder or want to see what function you'd use.  And often, the visualization will reveal even more about what's going than the formula or the code.  In short, there are a lot of tools at your disposal to help learn modeling in a way that works for you.  We hope that diving into the internal workings of models also allows you to see how they connect to each other if you choose that route, and this provides a nice roadmap from chapter to chapter.

[^formulas]: We actually never had this ability.

## What You Can Expect

For each model that we cover, you can expect the following in terms of content:

  - Overview 
	
  - Why it's useful 
	
  - Conceptual example and interpretation 
	
  - Where the model lies in the grand scheme of topics that we will cover 
  
  - Key ideas and concepts 
  
  - Demonstration with data, code, results, and visualizations 
  
  - Commentary, cautions, and where to explore next 

The demonstrations will provide you the opportunity to get your hands as dirty as you wish. In our demonstrations, we will present the code in two ways:

  - standard functions (e.g., `lm` in R, `ols` in statsmodels.formula for Python) 

  - the complete steps to recreate the estimation process 

We are taking this approach for one reason: so that you can go as deep as you wish. If you are looking for a quick tutorial on helpful models, then you might not find yourself going any deeper than the standard functions (or even getting into the code at all). If you want to really dive into these models, then you might find yourself working through the complete steps. Another approach is to allow yourself some time between the standard functions and complete steps. You could work through the standard functions of every chapter, give it some time to marinate, and then work back through the complete steps. While we certainly recommend working through the chapters in order, we want to give you the flexibility to choose your own depth within each.

We hope that this book can serve as a "choose your own adventure" statistical reference. Whether you want a surface-level understanding, a deeper dive, or just want to be able to understand what the analysts in your organization are talking about, you will find value in this book. While we assume that you have a basic familiarity with coding, that doesn't mean that you need to work through every line of code to understand the fundamental principles and use cases of every model.

## Which Language?

You've probably noticed most books, blogs, and courses on data science choose R or Python. While many individuals often take an opinionated approach towards teaching and using one over the other, we eschew dogmatic approaches and language flame wars. R and Python are both great languages (and equally flawed in unique ways), and it is advantageous to be knowledgeable of both, even if you focus on one specifically, as they are the most popular languages for statistical modeling and machine learning. We use both extensively in our own work and for teaching, for personal use, and for production level code, and have found both are up to whatever task you have in mind.  Throughout this book, we will be presenting demonstrations in both R and Python, and you can use both or take your pick, but we want to leave that choice up to you. Our goal isn't to obscure the ideas behind packages and specialty functions or tell you why one languages is superior to the other (they aren't), but to show you the most basic functions behind big model ideas. 

While we want to provide you choice, we truly hope that displaying both languages can help people to "convert" from one to the other. We have spent countless hours, slumped over our computers, debugging errors and figuring things out. If we can take away one source of pain for you, that would be great! We'd like to consider this as a resource for the R user, who knows exactly what they want to do in R, but could use a little help translating their R knowledge to Python; we'd also like this book to be a resource for the Python user, who sees the value in R's statistical modeling abilities.

## Choose Your Own Adventure

Before we get into some more interesting things in the next chapters, let's warm up a bit by looking at that correlation formula again and working through it together:

$$
r = \frac{\Sigma(x_i-\bar{x})(y_i-\bar{y})}{\sqrt{\Sigma(x_i-\bar{x})^2\Sigma(y_i-\bar{y})^2}}
$$

What everyone typically just calls "correlation" or Pearson's *r* is actually the *Pearson Product-Moment Correlation* -- that is a lot of words, though, so we will just go with correlation. As we mentioned earlier, we want to give you the choice to dive in as deep as you want. If you want just a little bit of background, you can read through the *Overview* section. If you want to see the easy way to use the model, you can work through the *Standard Function* section. If you want to see the method from start to finish, feel free to work through the *Long Form* section. If all of that sounds like a lot of work and you'd rather make pictures, check out the *Visualization* section.

### Overview

Let's consider the numerator first: 

$$\Sigma(x_i-\bar{x})(y_i-\bar{y})$$

Variables *x* and *y* are nothing but columns within data: maybe height and weight, years worked and salary, or vertical jump and broad jump distance. Everything with a bar over it -- $\bar{x}$ and $\bar{y}$ -- indicates the mean of the variable. Everything with a subscripted *i* -- $x_i$ and $y_i$ -- indicates every observation of that variables. Said in real words, then, we are going to subtract the mean of *x* from every observation of *x*, subtract the mean of *y* from every observation of *y*, multiply them together, and then sum them to produce a single value. If you've taken a statistics class before, you might have seen this part of the formula when talking about *covariance* -- the joint variability of two variables. 

Covariance values, though, are not standardized; therefore, they are a bit tough to interpret. You will get a sign indicating relationship (just like a correlation) and the magnitude tells you the strength of the relationship, but it is hard to get your head around how much stronger a covariance of 4.00 is compared to a covariance of 0.28. 

This is where the denominator comes into play: 

$$\sqrt{\Sigma(x_i-\bar{x})^2\Sigma(y_i-\bar{y})^2}$$

To put it into real terms, we will subtract the mean of *x* from every observation of *x*, square those values, and sum those values to produce a single value. We will do the same for *y*, multiply *x* and *y*, and then take the square root of that product.

A great deal of the denominator might also look familiar! The individual pieces -- $\Sigma(x_i-\bar{x})^2$ and $\Sigma(y_i-\bar{y})^2$ -- are also used to compute *variance*. Taking the square root of variance gives us the *standard deviation*.  

Putting it all together, we are simply looking at the ratio of covariance (i.e., how much two variables "move" together) and standard deviation (i.e., the amount of dispersion within a variable). Just as we mentioned earlier, simple concepts often tie models together! What might look like a tricky formula, is really just a combination of means, variance, covariance, and standard deviations!

Just as a reminder, this correlation will give us an idea about the linear relationship between two continuous variables; we will get a value between -1 and 1, with values closer to 0 indicating that there is no linear relationship between the two variables. As values get closer to 1, we have a *positive correlation* -- as values for one variable increase, values for the other variable increase along with it. As values get closer to -1, we have a *negative correlation* -- as values for one variable increase, values for the other variable decrease along with it. Correlations can be useful for quickly exploring linear relationships, but let's not get too excited about it -- they aren't going to help you answer any big questions! We also don't want to get too carried away with "statistical significance" yet -- once samples get large, even small correlations become "significant". Instead, just use correlations to explore the patterns within your data, start getting ideas about interesting relationships that you might find, and leave worries about significance for people with more time on their hands.

## R

We can start by generating *x* as a random sample from a standard normal distribution:

```{r}
set.seed(seed = 1001)

x <- rnorm(n = 1000, mean = 0, sd = 1)
```

And we can create a vector for *y*:

```{r}
y <- rnorm(n = 1000, mean = 5, sd = 2)
```

Check out the plot of those two values:

```{r, echo = FALSE}
library(ggplot2)

ggplot(data.frame(x, y), aes(x, y)) +
  geom_point() + 
  theme_minimal()
```

Remember that correlation is testing for the presence of a linear relationship, with -1 indicating a perfect negative relationship, 1 indicating a perfect positive relationship, and 0 indicating no relationship. Before we see the actual correlation value for these two variables, take a guess as to what value we are going to get!

### Standard Function

Before we break it down into the long form, let's see what R's `cor` function gives us:

```{r}
cor(x, y)
```

When you guessed the value, did you say 0? If you did, you were pretty close! We have a negative value, but with a value so close to 0, this correlation is certainly nothing impressive and there isn't a linear relationship to be found -- we wouldn't expect impressive results with random numbers! We already know the answer, so let's make sure that we can get the same answer by working through the formula. 

### Long Form

Since we have our x and y vectors already, we can compute the averages -- representing $\bar{x}$ and $\bar{y}$ -- for both:

```{r}
x_bar <- mean(x = x)

y_bar <- mean(x = y)
```

Let's work through the numerator first. For the first term, $x_i-\bar{x}$, we can subtract `x_bar` from every value of *x*. This tells us how much each observation of *x* differs from the mean of *x*. 

```{r}
x_minus_x_mean <- x - x_bar
```

And then repeat that for *y*:

```{r}
y_minus_y_mean <- y - y_bar
```

We can wrap up the numerator by summing those multiplied values:

```{r}
numerator <- sum(x_minus_x_mean * y_minus_y_mean)

numerator
```

Shifting to the denominator, we see that we have already completed a large portion of the work; we can take our `x_minus_x_mean` and `y_minus_y_mean` values, square each to make make them positive, and then sum each:

```{r}
x_minus_x_mean_squared <- sum(x_minus_x_mean^2)

y_minus_y_mean_squared <- sum(y_minus_y_mean^2)
```

To finish up the denominator, all we need to do is to multiply those terms and take the square root:

```{r}
denominator <- sqrt(x_minus_x_mean_squared * y_minus_y_mean_squared)
```

And we can finish it up:

```{r}
numerator / denominator
```

While the long form certainly took more lines of code, we can see that breaking it down into smaller steps isn't difficult. 

For the sake of completeness, let's see how we would do the same thing with Python. We can start by generating our *x* and *y* vectors with `numpy`:

```{python}
import numpy as np

np.random.seed(seed=1001)

x = np.random.normal(loc=0, scale=1, size=1000)

y = np.random.normal(loc=5, scale=2, size=1000)
```

## Python

### Standard Function

Now we can easily get the correlation value:

```{python}
np.corrcoef(x, y)
```

Now we can go through the same steps to get the numerator value, first by finding the means of *x* and *y*. 

```{python}
x_bar = x.mean()

y_bar = y.mean()
```

And then subtracting those means from each observation of *x* and *y*: 

```{python}
x_minus_x_mean = x-x_bar

y_minus_y_mean = y-y_bar
```

We can then take the product of those two vectors and sum them into a single value: 

```{python}
numerator = sum(x_minus_x_mean * y_minus_y_mean)
```

So far so good! Let's square each x_minus_x_mean and y_minus_y_mean, and produce a sum for each: 

```{python}
x_minus_x_mean_squared = np.sum(x_minus_x_mean**2)

y_minus_y_mean_squared = np.sum(y_minus_y_mean**2)
```

We can then take the square root of the product of those squared values:

```{python}
denominator = np.sqrt(
  x_minus_x_mean_squared *
  y_minus_y_mean_squared
  )
```

The last step is still to divide the numerator by the denominator:

```{python}
numerator / denominator
```

It doesn't matter which language we use, the steps are largely the same when we break it down into the individual pieces!

### Visualization

Before gray started creeping into facial hair, the authors of this book worked together. While there were many great learning opportunities, working with clients showed us all of the help that people really needed in working with data and models. There were many requests that made us grimace, but one request stood atop Mount Ridiculous: to produce a correlation matrix with 115 variables and export that matrix to a spreadsheet. Since we were in the business of helping people do their work better, the obvious suggestion was a *corrplot*.

We don't want to pass along that same type of pain to you, so we will make a smaller data frame:

```{r}
set.seed(1001)

correlation_data <- data.frame(
  a = rnorm(n = 1000, mean = 0, sd = 1), 
  b = rnorm(n = 1000, mean = 5, sd = 2), 
  c = rnorm(n = 1000, mean = 10, sd = 4)
)
```

Let's add a few more variables to our data frame. These items are added for the sake of creating correlated variables in the data. 

```{r}
correlation_data$x <- correlation_data$a + 
  runif(n = 1000, min = 0, max = 5)

correlation_data$y <- correlation_data$b + 
  runif(n = 1000, min = 0, max = 10)

correlation_data$z <- -.5 * 
  (correlation_data$c + sqrt((1 - (.5)))) * 
  correlation_data$c
```

And then we can take a quick look at the *correlation matrix*:

```{r}
correlation_matrix <- cor(correlation_data)

correlation_matrix
```

Now we have the *pairwise correlations* between all six of our variables, with 1's on the diagonals (naturally, a variable has a perfect correlation with itself). You can check out the lower diagonal or the upper diagonal, because they contain the exact same information. Quickly, though, find the interesting pattern in that matrix!

Producing the correlations between just 6 variables gives us 15 correlation coefficients to examine! You can see that you'll need to spend more than a few seconds on finding the interesting patterns within the data (or if there are any patterns at all). Our brains are oriented towards vision, so we can use *preattentive processing* elements, like hue, saturation, and size, to make finding interesting patterns easier. 

Since we already have a correlation matrix, let's produce the easiest possible corrplot, using the `corrplot` package:


::: {.callout-note}
The `corrplot` package offers easy methods for visualizing correlation matrices. The `ggcor` package is a notable alternative, with more flexibility and arguably better aesthetics.
:::

```{r}
library(corrplot)

corrplot.mixed(correlation_matrix)
```

Let's break down what we're seeing just a little bit. The lower triangle has the correlation values. It adds information, though, by changing the hue by correlation value -- red for negative values and blue for positive values -- and increasing the saturation as the correlation value becomes stronger. The upper triangle contains the same information, but the size of the circle is tied directly to the strength of the correlation. You'll also notice that the weaker correlations are essentially hidden in the visualization, allowing us to focus only on those interesting relationships.

What do you think? Was it easier to spot the points of interest?

Let's see how we can handle this same task in Python. We will start by creating a `pandas` data frame.

```{python}
from biokit.viz import corrplot
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import seaborn as sns

data = {'a': np.random.normal(loc=0, scale=1, size=1000),
        'b': np.random.normal(loc=5, scale=2, size=1000),
        'c': np.random.normal(loc=10, scale=4, size=1000)}

# Create DataFrame
correlation_data = pd.DataFrame(data)

correlation_matrix = correlation_data.corr()
```

Adding a few variables to that data frame:

```{python}
correlation_data['x'] = (correlation_data['a']
  + np.random.uniform(low=0, high=5, size=1000))

correlation_data['y'] = (correlation_data['b']
  + np.random.uniform(low=0, high=10, size=1000))

correlation_data['z'] = (-.5
  * (correlation_data['c']
  + np.sqrt((1-(.5)))
  * correlation_data['c']))

```

Producing the correlation matrix:

```{python}
correlation_matrix = correlation_data.corr()
```

And using `seaborn` to produce a heat map:

```{python}
sns.heatmap(correlation_matrix, annot=True)

plt.show()
```

We could also use the `corrplot` function from `biokit` to get something a little nicer out of the box:

```{python}
c = corrplot.Corrplot(correlation_matrix)

c.plot(lower='text', upper='circle')

plt.show()
```

## Moving Towards An Excellent Adventure

Remember the point we made about "choosing your own adventure"? Statistical modeling and programming is an adventure, even if you never leave your desk! Every situation calls for choices to be made and every choice you make will lead you down a different path. You will run into errors, dead ends, and you might even find that you've spent considerable time to conclude that nothing interesting is happening in your data. This, no doubt, is part of the fun and all of those struggles make success that much sweeter. Like every adventure, things might not be immediately clear and you might find yourself in perilous situations! If you find that something isn't making sense upon your first read, that is okay. Both authors have spent considerable time mulling over models and foggy ideas during our assorted (mis)adventures; nobody should expect to master complex concepts on a single read through! In any arena where you strive to develop skills, distributed practice and repetition are essential. When concepts get tough, step away from the book, and come back with a fresh mind.

Thanks for coming on this adventure with us and welcome to our *Book of Models*. 
